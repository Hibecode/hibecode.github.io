<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Virtual IoT-Based ECG System</title>

<!-- Chart.js -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
<!-- jsPDF -->
<script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>

<style>
  :root {
    --bg: #0f172a;
    --panel: #111827;
    --muted: #94a3b8;
    --text: #e5e7eb;
    --accent: #38bdf8;
    --good: #22c55e;
    --warn: #f59e0b;
    --bad: #ef4444;
  }
  * { box-sizing: border-box; }
  body {
    margin: 0; background: var(--bg); color: var(--text);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans", sans-serif;
  }
  header {
    padding: 18px 20px; border-bottom: 1px solid #1f2937; background: #0b1220;
  }
  header h1 { margin: 0; font-size: 20px; letter-spacing: 0.2px; }
  main { max-width: 1100px; margin: 0 auto; padding: 20px; }
  .card {
    background: var(--panel); border: 1px solid #1f2937; border-radius: 14px; padding: 16px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.25);
  }
  .grid {
    display: grid; gap: 16px;
  }
  .grid.cols-2 { grid-template-columns: 1fr 1fr; }
  .grid.cols-3 { grid-template-columns: 1fr 1fr 1fr; }
  @media (max-width: 900px) {
    .grid.cols-2, .grid.cols-3 { grid-template-columns: 1fr; }
  }
  label { font-size: 14px; color: var(--muted); display: block; margin-bottom: 6px; }
  input, select {
    width: 100%; padding: 10px 12px; border-radius: 10px;
    border: 1px solid #1f2937; background: #0b1220; color: var(--text);
    outline: none;
  }
  input:focus, select:focus { border-color: var(--accent); }
  button {
    appearance: none; border: 1px solid #1f2937; color: var(--text);
    background: #0b1220; border-radius: 12px; padding: 10px 14px; cursor: pointer;
  }
  button.primary { background: var(--accent); color: #00121c; border: none; font-weight: 600; }
  button.danger { background: var(--bad); border: none; }
  .toolbar { display: flex; gap: 8px; flex-wrap: wrap; }
  .title { margin: 0 0 8px 0; font-size: 16px; }
  .muted { color: var(--muted); font-size: 14px; }
  .kv { margin: 8px 0; display: grid; grid-template-columns: 150px 1fr; gap: 6px 16px; }
  .badge { display: inline-block; padding: 4px 8px; border-radius: 999px; font-size: 12px; border: 1px solid #1f2937; background: #0b1220; }
  .badge.good { border-color: #134e4a; background: #052e2b; color: #34d399; }
  .badge.warn { border-color: #4a3007; background: #2a1b04; color: #fbbf24; }
  .badge.bad { border-color: #4c0519; background: #2a0612; color: #fb7185; }
  .row { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
  canvas { background: #06111b; border-radius: 10px; }
  .note { font-size: 12px; color: var(--muted); }
  .hidden { display: none !important; }
</style>
</head>
<body>
<header>
  <h1>Virtual IoT-Based ECG System</h1>
</header>

<main>
  <!-- Patient Intake -->
  <section id="view-intake" class="card">
    <h2 class="title">Patient Intake</h2>
    <p class="muted">Enter patient details and choose data source. You can test with simulated ECG if Ubidots is not ready.</p>
    <div class="grid cols-3" style="margin-top:12px">
      <div>
        <label>Patient Name</label>
        <input id="p-name" placeholder="e.g., John Doe" />
      </div>
      <div>
        <label>Patient ID</label>
        <input id="p-id" placeholder="e.g., P12345" />
      </div>
      <div>
        <label>Age</label>
        <input id="p-age" type="number" min="0" max="120" placeholder="e.g., 40" />
      </div>
      <div>
        <label>Gender</label>
        <select id="p-gender">
          <option value="">Select...</option>
          <option>Male</option>
          <option>Female</option>
          <option>Other</option>
        </select>
      </div>
      <div>
        <label>Ubidots Token</label>
        <input id="ubidots-token" placeholder="YOUR_UBIDOTS_TOKEN_HERE" />
      </div>
      <div>
        <label>Device / Variable</label>
        <input id="ubidots-path" placeholder="esp32/sensor" />
      </div>
    </div>

    <div class="row" style="margin-top:14px">
      <label class="muted">Data Source</label>
      <select id="data-source">
        <option value="ubidots">Ubidots REST API</option>
        <option value="sim">Simulated ECG</option>
      </select>
    </div>

    <div class="toolbar" style="margin-top:14px">
      <button class="primary" id="btn-start">Start Monitoring</button>
      <button id="btn-fill-demo">Fill Demo Data</button>
    </div>
  </section>

  <!-- Dashboard -->
  <section id="view-dash" class="hidden">
    <div class="grid cols-2">
      <div class="card">
        <div class="row" style="justify-content:space-between; align-items:baseline">
          <h2 class="title">Live ECG</h2>
          <div class="toolbar">
            <button id="btn-pause">Pause</button>
            <button id="btn-resume" class="primary">Resume</button>
            <button id="btn-export">Export PDF</button>
          </div>
        </div>
        <p class="muted">Stream processing: bandpass, baseline correction, Pan–Tompkins QRS detection, HR estimation.</p>
        <canvas id="ecgChart" height="220"></canvas>
        <div class="row" style="margin-top:10px">
          <span class="badge" id="status-source">Source: Ubidots</span>
          <span class="badge" id="status-qrs">QRS detection: active</span>
          <span class="badge" id="status-conn">Connecting...</span>
        </div>
        <p class="note" style="margin-top:6px">
          If you hit CORS issues in the browser, host this file on a simple local server or use a small proxy.
        </p>
      </div>

      <div class="grid cols-1">
        <div class="card">
          <h2 class="title">Patient</h2>
          <div class="kv">
            <div class="muted">Name</div><div id="kv-name">—</div>
            <div class="muted">ID</div><div id="kv-id">—</div>
            <div class="muted">Age</div><div id="kv-age">—</div>
            <div class="muted">Gender</div><div id="kv-gender">—</div>
          </div>
        </div>

        <div class="card">
          <h2 class="title">Computed Metrics</h2>
          <div class="kv">
            <div class="muted">Heart Rate</div><div id="kv-hr">—</div>
            <div class="muted">Last RR</div><div id="kv-rr">—</div>
            <div class="muted">RR Variance</div><div id="kv-rrvar">—</div>
            <div class="muted">QRS Width</div><div id="kv-qrsw">—</div>
            <div class="muted">Summary</div><div id="kv-summary">—</div>
          </div>
          <div style="margin-top:8px">
            <span class="badge good" id="flag-nsr">NSR</span>
            <span class="badge warn" id="flag-brady">Brady</span>
            <span class="badge warn" id="flag-tachy">Tachy</span>
            <span class="badge bad" id="flag-arr">Arrhythmia</span>
          </div>
        </div>

        <div class="card">
          <h2 class="title">Controls</h2>
          <div class="row">
            <button id="btn-clear">Clear Graph</button>
            <button id="btn-threshold">Recalibrate Threshold</button>
            <button class="danger" id="btn-stop">Stop</button>
          </div>
          <p class="note" style="margin-top:8px">
            Threshold recalibration uses recent baseline to adapt to signal scale. Useful after lead adjustments.
          </p>
        </div>
      </div>
    </div>
  </section>
</main>

<script>
  // ========= Config =========
  const UBIDOTS_BASE = "https://industrial.api.ubidots.com/api/v1.6/devices";
  const POLL_MS = 1000;            // fetch interval from Ubidots
  const DRAW_HZ = 50;              // target chart update cadence
  const BUFFER_SECONDS = 10;       // visible window
  const SAMPLE_FS = 125;           // expected sampling rate (Hz) after reconstruction
  const MW_INT_MS = 150;           // Pan–Tompkins moving window integration length

  // ========= State =========
  const state = {
    running: false,
    paused: false,
    src: "ubidots",                // or "sim"
    token: "",
    device: "esp32",
    variable: "sensor",
    patient: { name: "", id: "", age: "", gender: "" },
    lastTime: 0,
    buf: [],                       // signal buffer
    time: [],                      // ms timeline
    peaks: [],                     // detected R-peaks [ {t, i, val} ]
    rrHistory: [],                 // last N RR intervals (s)
    chart: null,
    threshold: null,               // adaptive threshold for QRS
    hp_y1: 0, hp_x1: 0,            // high-pass filter state
    lp_prev: 0,                    // low-pass (simple)
  };

  // ========= UI Elements =========
  const $ = sel => document.querySelector(sel);
  const intake = {
    name: $("#p-name"), id: $("#p-id"), age: $("#p-age"), gender: $("#p-gender"),
    token: $("#ubidots-token"), path: $("#ubidots-path"), source: $("#data-source"),
    start: $("#btn-start"), fill: $("#btn-fill-demo")
  };
  const dash = {
    view: $("#view-dash"),
    intake: $("#view-intake"),
    statusSource: $("#status-source"),
    statusConn: $("#status-conn"),
    kv: {
      name: $("#kv-name"), id: $("#kv-id"), age: $("#kv-age"), gender: $("#kv-gender"),
      hr: $("#kv-hr"), rr: $("#kv-rr"), rrvar: $("#kv-rrvar"), qrsw: $("#kv-qrsw"), sum: $("#kv-summary")
    },
    flags: { nsr: $("#flag-nsr"), brady: $("#flag-brady"), tachy: $("#flag-tachy"), arr: $("#flag-arr") },
    pause: $("#btn-pause"), resume: $("#btn-resume"), stop: $("#btn-stop"),
    export: $("#btn-export"), clear: $("#btn-clear"), thresh: $("#btn-threshold"),
  };

  // ========= Helpers =========
  function setFlags({nsr, brady, tachy, arr}) {
    dash.flags.nsr.style.opacity = nsr ? 1 : 0.3;
    dash.flags.brady.style.opacity = brady ? 1 : 0.3;
    dash.flags.tachy.style.opacity = tachy ? 1 : 0.3;
    dash.flags.arr.style.opacity = arr ? 1 : 0.3;
  }
  function ms() { return performance.now(); }

  // Simple high-pass IIR to remove baseline
  function highPass(x, alpha = 0.995) {
    const y = alpha * (state.hp_y1 + x - state.hp_x1);
    state.hp_y1 = y; state.hp_x1 = x;
    return y;
  }
  // Simple low-pass smoothing
  function lowPass(x, alpha = 0.3) {
    const y = state.lp_prev + alpha * (x - state.lp_prev);
    state.lp_prev = y;
    return y;
  }

  // Pan–Tompkins style pipeline on one sample
  // 1) Bandpass (HP + LP), 2) Derivative, 3) Squaring, 4) Moving window integration, 5) Thresholding
  const derivBuf = [];
  const mwiBuf = [];
  let lastDeriv = 0;
  let lastSample = 0;
  let lastPeakTime = null;

  function panTompkinsStep(x, t_ms) {
    // bandpass
    const hp = highPass(x);
    const bp = lowPass(hp);

    // derivative
    const d = bp - lastSample;
    lastSample = bp;

    // squaring
    const s = d * d;

    // moving window integration
    const mwiLen = Math.max(3, Math.round((MW_INT_MS / 1000) * SAMPLE_FS));
    mwiBuf.push(s);
    if (mwiBuf.length > mwiLen) mwiBuf.shift();
    const mwi = mwiBuf.reduce((a, b) => a + b, 0) / mwiBuf.length;

    // adaptive threshold
    if (state.threshold === null) {
      // warmup with median of first seconds
      const warm = mwiBuf.slice(-Math.min(mwiBuf.length, SAMPLE_FS * 2));
      const med = warm.slice().sort((a,b)=>a-b)[Math.floor(warm.length/2)] || 0.001;
      state.threshold = med * 5;
    } else {
      // slowly adapt
      state.threshold = 0.995 * state.threshold + 0.005 * mwi;
    }

    const isPeak = mwi > state.threshold;
    // Edge and refractory handling
    let detected = false;
    if (isPeak) {
      const now = t_ms;
      if (!lastPeakTime || (now - lastPeakTime) > 200) { // 200ms refractory
        lastPeakTime = now;
        detected = true;
      }
    }
    return { bp, mwi, detected };
  }

  function updateMetrics(t_ms, detected, value) {
    if (detected) {
      state.peaks.push({ t: t_ms, val: value });
      if (state.peaks.length >= 2) {
        const n = state.peaks.length;
        const rr = (state.peaks[n - 1].t - state.peaks[n - 2].t) / 1000;
        state.rrHistory.push(rr);
        if (state.rrHistory.length > 10) state.rrHistory.shift();

        const hr = rr > 0 ? Math.round(60 / rr) : 0;
        dash.kv.hr.textContent = hr ? hr + " bpm" : "—";
        dash.kv.rr.textContent = rr.toFixed(2) + " s";
        const mean = state.rrHistory.reduce((a,b)=>a+b,0) / state.rrHistory.length;
        const variance = state.rrHistory.reduce((a,b)=>a + (b-mean)*(b-mean),0) / state.rrHistory.length;
        dash.kv.rrvar.textContent = variance.toFixed(3);

        const brady = hr > 0 && hr < 60;
        const tachy = hr > 100;
        const arr = variance > 0.04; // rough
        const nsr = !brady && !tachy && !arr;

        dash.kv.sum.textContent = nsr ? "Normal sinus rhythm" :
                                   arr ? "Irregular rhythm detected" :
                                   brady ? "Possible bradycardia" :
                                   tachy ? "Possible tachycardia" : "—";

        setFlags({ nsr, brady, tachy, arr });
      }
    }
  }

  // ========= Chart =========
  function initChart() {
    const ctx = document.getElementById("ecgChart");
    state.chart = new Chart(ctx, {
      type: "line",
      data: {
        labels: [],
        datasets: [
          { label: "ECG (filtered)", data: [], borderColor: "#38bdf8", borderWidth: 1, pointRadius: 0 },
          { label: "R-peak", data: [], borderColor: "#22c55e", borderWidth: 0, pointRadius: 3, showLine: false },
        ]
      },
      options: {
        animation: false,
        responsive: true,
        scales: {
          x: { ticks: { color: "#9ca3af" }, grid: { color: "#1f2937" } },
          y: { ticks: { color: "#9ca3af" }, grid: { color: "#1f2937" } },
        },
        plugins: {
          legend: { labels: { color: "#d1d5db" } },
        }
      }
    });
  }

  function pushToChart(t_ms, y, peakDetected) {
    const t_s = (t_ms / 1000).toFixed(2);
    const ds = state.chart.data.datasets;
    state.chart.data.labels.push(t_s);
    ds[0].data.push(y);
    if (peakDetected) ds[1].data.push({ x: t_s, y });
    else ds[1].data.push(null);

    // keep window
    const maxPoints = BUFFER_SECONDS * DRAW_HZ;
    if (ds[0].data.length > maxPoints) {
      state.chart.data.labels.shift();
      ds[0].data.shift();
      ds[1].data.shift();
    }
    state.chart.update();
  }

  function clearChart() {
    state.chart.data.labels = [];
    state.chart.data.datasets[0].data = [];
    state.chart.data.datasets[1].data = [];
    state.chart.update();
  }

  // ========= Data Fetching =========
  let pollTimer = null;
  let drawTimer = null;
  let simPhase = 0;
  function simulateSample() {
    // 1.1 Hz heart rate base with noise
    const f = 1.1;
    simPhase += 2 * Math.PI * f / SAMPLE_FS;
    const base = Math.sin(simPhase) * 0.5;
    const qrs = Math.random() < 0.02 ? 2.2 : 0;
    const noise = (Math.random() - 0.5) * 0.15;
    return base + qrs + noise;
  }

  async function fetchUbidotsLatest(token, device, variable) {
    const url = `${UBIDOTS_BASE}/${encodeURIComponent(device)}/${encodeURIComponent(variable)}/lv`;
    const res = await fetch(url, {
      headers: { "X-Auth-Token": token }
    });
    if (!res.ok) throw new Error("Ubidots fetch failed " + res.status);
    const json = await res.json();
    // Expecting { results: [ { value, timestamp } ] }
    if (!json.results || !json.results.length) throw new Error("No values");
    const v = json.results[0];
    return { value: v.value, ts: v.timestamp };
  }

  function startPolling() {
    if (pollTimer) clearInterval(pollTimer);
    if (drawTimer) clearInterval(drawTimer);

    // Reset processing
    state.buf = [];
    state.time = [];
    state.peaks = [];
    state.rrHistory = [];
    state.threshold = null;
    state.hp_y1 = 0; state.hp_x1 = 0; state.lp_prev = 0;
    lastDeriv = 0; lastSample = 0; lastPeakTime = null;
    clearChart();

    // Poll loop
    pollTimer = setInterval(async () => {
      if (!state.running || state.paused) return;
      try {
        let raw = 0;
        let t = ms();

        if (state.src === "ubidots") {
          const latest = await fetchUbidotsLatest(state.token, state.device, state.variable);
          // Reconstruct to sample rate by duplicating the last value across 1 sec
          const samples = Math.max(1, Math.round(SAMPLE_FS * (POLL_MS / 1000)));
          for (let i = 0; i < samples; i++) {
            const val = latest.value; // assume already scaled; normalize below
            state.buf.push(val);
            state.time.push(ms());
            // keep long buffer for processing if you want historical analysis
            if (state.buf.length > SAMPLE_FS * 60) {
              state.buf.shift(); state.time.shift();
            }
          }
          dash.statusConn.textContent = "Connected";
        } else {
          // Simulation
          for (let i = 0; i < Math.round(SAMPLE_FS * POLL_MS / 1000); i++) {
            const val = simulateSample();
            state.buf.push(val);
            state.time.push(ms());
            if (state.buf.length > SAMPLE_FS * 60) {
              state.buf.shift(); state.time.shift();
            }
          }
          dash.statusConn.textContent = "Simulating";
        }
      } catch (e) {
        dash.statusConn.textContent = "Error";
        console.error(e);
      }
    }, POLL_MS);

    // Draw loop at DRAW_HZ
    drawTimer = setInterval(() => {
      if (!state.running || state.paused) return;
      if (!state.buf.length) return;
      // process one sample per draw tick to animate
      const remaining = Math.min(state.buf.length, Math.ceil(SAMPLE_FS / DRAW_HZ));
      for (let i = 0; i < remaining; i++) {
        const raw = state.buf.shift();
        const t_ms = state.time.shift() ?? ms();

        // normalize raw into roughly mV scale
        const norm = (raw - 512) / 200; // tweak depending on ADC scale; Ubidots raw may differ

        const { bp, mwi, detected } = panTompkinsStep(norm, t_ms);
        updateMetrics(t_ms, detected, bp);
        pushToChart(t_ms, bp, detected);
      }
    }, 1000 / DRAW_HZ);
  }

  // ========= PDF Export =========
  async function exportPDF() {
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF({ unit: "pt", format: "a4" });
    const pad = 36;

    doc.setFont("helvetica", "bold");
    doc.setFontSize(14);
    doc.text("Virtual IoT-Based ECG Report", pad, 48);

    doc.setFont("helvetica", "normal");
    doc.setFontSize(11);
    doc.text(`Patient: ${state.patient.name}   ID: ${state.patient.id}`, pad, 72);
    doc.text(`Age: ${state.patient.age}   Gender: ${state.patient.gender}`, pad, 90);
    doc.text(`Source: ${state.src === "ubidots" ? "Ubidots REST API" : "Simulated"}`, pad, 108);

    const canvas = document.getElementById("ecgChart");
    const dataUrl = canvas.toDataURL("image/png", 0.95);
    doc.addImage(dataUrl, "PNG", pad, 130, 523, 220);

    doc.setFont("helvetica", "bold");
    doc.text("Summary", pad, 380);
    doc.setFont("helvetica", "normal");
    doc.text(`Heart Rate: ${dash.kv.hr.textContent}`, pad, 400);
    doc.text(`Last RR: ${dash.kv.rr.textContent}`, pad, 416);
    doc.text(`RR Variance: ${dash.kv.rrvar.textContent}`, pad, 432);
    doc.text(`QRS Width: ${dash.kv.qrsw.textContent}`, pad, 448);
    doc.text(`Assessment: ${dash.kv.sum.textContent}`, pad, 464);

    doc.save(`ECG_Report_${state.patient.id || "patient"}.pdf`);
  }

  // ========= Events =========
  intake.fill.addEventListener("click", () => {
    intake.name.value = "Demo Patient";
    intake.id.value = "P1001";
    intake.age.value = "45";
    intake.gender.value = "Male";
    intake.token.value = "YOUR_UBIDOTS_TOKEN_HERE";
    intake.path.value = "esp32/sensor";
    intake.source.value = "sim";
  });

  intake.start.addEventListener("click", () => {
    const [device, variable] = (intake.path.value || "esp32/sensor").split("/");
    state.patient = {
      name: intake.name.value.trim(),
      id: intake.id.value.trim(),
      age: intake.age.value.trim(),
      gender: intake.gender.value,
    };
    state.token = intake.token.value.trim();
    state.src = intake.source.value;
    state.device = device || "esp32";
    state.variable = variable || "sensor";

    if (state.src === "ubidots" && !state.token) {
      alert("Please enter your Ubidots Token or choose Simulated ECG.");
      return;
    }

    $("#kv-name").textContent = state.patient.name || "—";
    $("#kv-id").textContent = state.patient.id || "—";
    $("#kv-age").textContent = state.patient.age || "—";
    $("#kv-gender").textContent = state.patient.gender || "—";

    dash.statusSource.textContent = "Source: " + (state.src === "ubidots" ? "Ubidots" : "Simulated");
    state.running = true;
    intake.start.disabled = true;

    // switch views
    intakeView(false);
    initChart();
    startPolling();
  });

  function intakeView(show) {
    dash.intake.classList.toggle("hidden", !show);
    dash.view.classList.toggle("hidden", show);
  }

  dash.pause.addEventListener("click", () => state.paused = true);
  dash.resume.addEventListener("click", () => state.paused = false);
  dash.stop.addEventListener("click", () => {
    state.running = false;
    state.paused = false;
    if (pollTimer) clearInterval(pollTimer);
    if (drawTimer) clearInterval(drawTimer);
    intake.start.disabled = false;
    intakeView(true);
  });
  dash.clear.addEventListener("click", clearChart);
  dash.thresh.addEventListener("click", () => state.threshold = null);
  dash.export.addEventListener("click", exportPDF);
</script>
</body>
</html>
